<html>

    <head> 
        <script src="build/sigma.min.js"></script>
        <script src="build/plugins/sigma.parsers.json.min.js"></script>
        <script src="build/plugins/sigma.plugins.animate.min.js"></script>
        <script src="build/plugins/sigma.plugins.animate.js"></script> 
        <script src="build/plugins/sigma.plugins.dragNodes.min.js"></script>
        <script src="build/plugins/sigma.layout.forceAtlas2.min.js"></script>
        <script src = "build/plugins/sigma.layout.noverlap.min.js"></script>
        <script src = "build/plugins/sigma.exporters.svg.min.js"></script>
        <script src = "build/plugins/sigma.renderers.snapshot.min.js"></script>

        <meta charset="utf-8" />
        <title>Network Simulation Prototype</title> 
        
        <link rel="stylesheet" type="text/css" href="style.css">
    </head>
    
    <body>
        <!--Sidebar-->
        <div class="sidebar">
            <h1>Network Simulator</h1>

            <div>
                <!--Instructions-->
                <button class="collapsible">Instructions:</button>
                <div class="content">
                    <p>1. Select input .csv file</p>
                    <p>1.1 Click the animate button to change the view or pause it if there's a glitch</p> <!--(not sure if we should keep this in the instructions or just keep it in the user manual)-->
                    <p>2. Edit the network</p>
                    <p>3. Configure a routing simulation</p>
                    <p>4. View and download perfromance data</p>
                </div>
            </div>

            <div style="text-align: center;">
                <!--Select csv-->
                <h3>Select an input csv file</h3>
                <div class="box">
                    <br>
                    <input type="file" onchange='openFile(event)'>
                    <br><br>

                    <div style="text-align: center;">
                        <form action="/action_page.php">
                        <button id="layout" type="button">Animate</button>
                        <br><br>
                        <button type="button" onclick="dothings()">
                           DO THE THINGS!!!!
                        </button>

                        </form>
                    </div>
                </div>
            </div>



            <div>
                <!--Edit network-->
                <h3>Edit the network</h3>
                <button class="collapsible">Add a node</button>
                <div class="content">
                    <form action="/action_page.php">
                        <br>
                        <!--##########################################################################################-->
                        Enter new node ID:<br>
                        <input type="text" name="newNode" value="" id="newNode">  
                        <br><br>
                        Enter Country Code <br>
                        <input type = "text" name = "nodeCountry" value = "" id="nodeCountry">
                        <br><br>
                        <!--##########################################################################################-->
                        Select node tier:<br>
                        <select id = "selectTier"> <!--Change this to options of the different node tiers-->
                            <option>Node Tier</option>
                        </select>
                        <br><br>

                        Select existing node to connect to:<br>
                        <select id = "existingNode"> <!--Change this to options of the different available nodes-->
                            <option>Node</option>
                        </select>
                        <br><br>

                        <!--##########################################################################################-->
                        Enter edge cost:<br>
                        <input type="text" name="edgeCost" value="" id="edgeCost">  
                        <br><br>
                        Enter Delay on edge:<br>
                        <input type = "text" name = "linkdelay" value = "" id="linkdelay">
                        <br><br>
                        


                        <button type="button" onclick="addNodeFunction()">
                           ADD
                        </button>
                        <!--##########################################################################################-->

                        <!--can't ask the user to input type of edge or cost of edge or delay of edge, that should be implemented automatically based on the type of node created and the type of node it's connected to-->

                    </form>
                </div>
                <button class="collapsible">Delete a node</button>
                <div class="content">
                    <form action="/action_page.php">
                        <br>
                        Select a node to delete:<br>
                        <select id = "nodeToDelete"> <!--Change this to a dropdown of all the available nodes-->
                            <option>Delete Node</option>
                        </select>
                        <br><br>
                        <!--##########################################################################################-->
                        <button type="button" onclick="deleteNodeFunction()">
                           DELETE
                        </button>
                        <!--##########################################################################################-->
                    </form>
                </div>
            </div>

            <div>
                <!--Configure routing simulation-->
                <h3>Configure a routing simulation</h3>
                <form class="box" action="/action_page.php">
                        Select start node:<br>
                        <select id="selectStart">
                                <option>Start Node</option>    
                        </select>
                        <br><br>

                        Select end node:<br>
                        <select id = "selectEnd">
                            <option>End Node</option>
                        </select>
                        <br><br>

                        Select a routing algorithm:<br>
                        <select id = "selectRoutingAlgorithm"> <!--Change this to options of the different routing algorithms-->
                            <option>Routing Algorithm</option>
                        </select>
                        <br><br>

                        How many times do you wish to run the simualtion (Frequency)?:<br>
                        <select id = "frequency"> <!--Change this - default must be 1 and allow them to run a max of 10 times (insert dropdown from 1-10)-->
                            <option>Frequency</option>
                        </select>
                        <br><br>

                        Delay between runs (only available if frequency is>0):<br>
                        <select id = "runs"> <!--Change this - default must be 0 and have delays of 1-5 seconds-->
                            <option>Delay</option>
                        </select>
                        <br>

                        <p id="demo"></p>
                        <p id="demo2"></p>

                        <button type="button" onclick="submitFunction()">
                            Submit
                        </button>
                        <br><br>

                </form>
            </div>

            <div style="text-align: center;">
                <!--Performance data-->
                <h3>Performance data</h3>
                <div class="box">
                    <br>
                    <button class="button" type="button" onclick="saveFunction()">
                    Download Performance Data
                    </button>
                    <br><br>

                    <button class="button" type="button" onclick="saveTPFunction()">
                    Download Network Topology Data
                    </button>
                    <br><br>
                </div>
            </div>

            <script>
                        var nodeIds = [];
                        var selectStart = document.getElementById("selectStart");
                        var selectEnd = document.getElementById("selectEnd");
                        var selectTier = document.getElementById("selectTier");
                        var nodeToDelete = document.getElementById("nodeToDelete");
                       
                        
                       
                      
                    
                        //console.log(nodeIds);

                       
                            let csvContent = "data:text/csv;charset=utf-8,";
                            var nodecounter = 0;
                            var edgecounter =0;
                            // Here the value is stored in new variable x  
                            // DO CHECK TO SEE GRAPH IS BUILT BEFORE ACCEPTING START AND END NODE

                            function deleteNodeFunction() {
                                
                                var deletedNodeIndex = graph.nodes.indexOf(nodeToDelete);


                                // Logic block for deleting nodes from database
//#######################################################################################################

                            var deleteNode = document.getElementById("nodeToDelete").value;
                            
                            
                            

                            if(localStorage.getItem("%n" +deleteNode)!=null){
                                        localStorage.removeItem("%n" +deleteNode);
                                        
                                    
                            }



                            // code to delete edges from database

                            var datafetch = Object.entries(localStorage);
                            
                            var splitexportdata = [];



                            for(var i = 0; i < datafetch.length; i++){
                                splitexportdata = splitexportdata.concat(datafetch[i]);
                            }



                            for(i=0;i<splitexportdata.length;i++){

                                
                                
                                
                                    if(splitexportdata[i].charAt(0)==="%" && splitexportdata[i].charAt(1)=== "e" && splitexportdata[i+1] ){
                                        if(splitexportdata[i]&&splitexportdata[i+1]){
                                            var edgedata = splitexportdata[i+1].split(",");
                                            if(edgedata[0].trim()===deleteNode || edgedata[1].trim()===deleteNode){

                                                var key = splitexportdata[i].trim();
                                                
                                                localStorage.removeItem(key);

                                            }
                                            
                                        
                                    }
                                    
                                }
                            }






//########################################################################################################




                                //console.log(graph.nodes);
                                graph.nodes.splice(deletedNodeIndex, 1);
                                //console.log(graph.nodes);
                                s.graph.clear();
                                s.graph.read(graph);
                                s.refresh();

                            }




//test block
//#########################################################################################################3###



							function dothings(){

								var pathdata = "ASN8,ASN6,ASN3,ASN1,ASN9,ASN42,IXP13,ASN41";
								lightpathIDs=pathdata.split(",");
								var firsts = "ASN8";
								var firstd ="ASN6";
								
								
                                	 
   									for (var i in graph.edges) {
     									if (graph.edges[i].source === firsts && graph.edges[i].target === firstd ) {
     										
        									graph.edges[i].color = "ff00f7";
        									break; //Stop this loop, we found it!
     									}
   									}
								



                                	

                                	//console.log(graph.edges);
                                	s.graph.clear();
                                	s.graph.read(graph);
                                	//  signma draws the graph
                                	//s.startForceAtlas2();
                                	s.refresh();
                                	

   							}

							










//#################################################################################################################
































                            function addNodeFunction() {

                                //#################################################################################
                                var sourceID = document.getElementById("newNode").value;
                                //#################################################################################
                                
                                var destiantionID = document.getElementById("existingNode").value;
                                var cost = parseInt(document.getElementById("edgeCost").value);
                                var nodeTier = document.getElementById("selectTier").value;
                                var Etype = ""; // no input for this anymore!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!



                                //logic for adding node to data base
        //##########################################################################################################





                            var nodecountry = document.getElementById("nodeCountry").value;
                            var delay = document.getElementById("linkdelay").value;
                            // data must be added to Node table and edge table in database here
                            // Source,Destination,Type,Cost,Delay



                            if (typeof(Storage) !== "undefined") {

                                nodecounter++;
                                edgecounter++;

                                var key1 = "%n"+ sourceID;
                                var key2 = "%edge" + edgecounter;
                                var data1 = nodeTier + "," + nodecountry;
                                localStorage.setItem(key1,data1);
                                var foundtierdata = "";
                                
                                if(localStorage.getItem("%n"+destiantionID)!=null){
                                    foundtierdata = localStorage.getItem("%n"+destiantionID).trim();
                                        
                                    

                                }
                                
                                var splitdata = foundtierdata.split(",");

// PLEASE NOTE THESE EDGE ADDS ONLY ALLOW FOR VALID NODE PAIRS I.E A T1 NODE CAN NEVER BE CONNECTED TO A T3 NODE
// MUST ADD ADDITIONAL STATEMENTS FOR OTHER RULE REQUIREMENTS I.E ALL TIERS 1 NODES MUST BE CONNECTED TO EACH OTHER

                                if(nodeTier==="T1" && splitdata[0].trim()==="T1" ){
                                    var data2 = sourceID + "," + destiantionID + "," + "P" + "," + cost + "," + delay; 
                                    localStorage.setItem(key2,data2); 
                                    edgecounter++;
                                    var extrakey = "%edge" + edgecounter;
                                    var extradata = destiantionID + "," + sourceID+ "," + "P"+ "," + cost + "," + delay ;
                                    localStorage.setItem(extrakey,extradata);
                                    Etype="P";
                                }
                                if(nodeTier==="T1" && splitdata[0].trim()==="T2" ){
                                    var data2 = sourceID + "," + destiantionID + "," + "PC" + "," + cost + "," + delay; 
                                    localStorage.setItem(key2,data2); 
                                    edgecounter++;
                                    var extrakey = "%edge" + edgecounter;
                                    var extradata = destiantionID + "," + sourceID+ "," + "CP"+ "," + cost + "," + delay ;
                                    localStorage.setItem(extrakey,extradata);
                                    Etype="PC";
                                }
                                if(nodeTier==="T2" && splitdata[0].trim()==="T1" ){
                                    var data2 = sourceID + "," + destiantionID + "," + "CP" + "," + cost + "," + delay; 
                                    localStorage.setItem(key2,data2); 
                                    edgecounter++;
                                    var extrakey = "%edge" + edgecounter;
                                    var extradata = destiantionID + "," + sourceID+ "," + "PC"+ "," + cost + "," + delay ;
                                    localStorage.setItem(extrakey,extradata);
                                    Etype="CP";
                                }
                                if(nodeTier==="T2" && splitdata[0].trim()==="T3" ){
                                    var data2 = sourceID + "," + destiantionID + "," + "PC" + "," + cost + "," + delay; 
                                    localStorage.setItem(key2,data2); 
                                    edgecounter++;
                                    var extrakey = "%edge" + edgecounter;
                                    var extradata = destiantionID + "," + sourceID+ "," + "CP"+ "," + cost + "," + delay ;
                                    localStorage.setItem(extrakey,extradata);
                                    Etype="PC";
                                }
                                if(nodeTier==="T3" && splitdata[0].trim()==="T2" ){
                                    var data2 = sourceID + "," + destiantionID + "," + "CP" + "," + cost + "," + delay; 
                                    localStorage.setItem(key2,data2); 
                                    edgecounter++;
                                    var extrakey = "%edge" + edgecounter;
                                    var extradata = destiantionID + "," + sourceID+ "," + "PC"+ "," + cost + "," + delay ;
                                    localStorage.setItem(extrakey,extradata);
                                    Etype="CP";
                                }
                                if(nodeTier==="T3" && splitdata[0].trim()==="IX" ){
                                    var data2 = sourceID + "," + destiantionID + "," + "IX" + "," + cost + "," + delay; 
                                    localStorage.setItem(key2,data2); 
                                    edgecounter++;
                                    var extrakey = "%edge" + edgecounter;
                                    var extradata = destiantionID + "," + sourceID+ "," + "IX"+ "," + cost + "," + delay ;
                                    localStorage.setItem(extrakey,extradata);
                                    Etype="IX";
                                }
                                if(nodeTier==="IX" && splitdata[0].trim()==="T3" ){
                                    var data2 = sourceID + "," + destiantionID + "," + "IX" + "," + cost + "," + delay; 
                                    localStorage.setItem(key2,data2); 
                                    edgecounter++;
                                    var extrakey = "%edge" + edgecounter;
                                    var extradata = destiantionID + "," + sourceID+ "," + "IX"+ "," + cost + "," + delay ;
                                    localStorage.setItem(extrakey,extradata);
                                    Etype="IX";
                                }
                                
                                
                                 
                            










                            } else {
                                document.getElementById("result").innerHTML = "Sorry, your browser does not support Web Storage...";
                            }






//############################################################################################################
                                
                                
                                if (selectTier === "T1") {

                                    graph.nodes.push({id: sourceID, size: 9, color: '#70c405', label: sourceID, x: Math.random(), y: Math.random()});
                                    graph.edges.push({id:sourceID,source:sourceID,target:existingNode,label:cost,colour:'#282c34',size:0.5});
                                    g.addEdge(sourceID, destiantionID, cost);
                                    nodeIds.push(sourceID);

                                    

                                }
                                if (selectTier === "T2") {
                                    graph.nodes.push({id: sourceID, size: 6, color: '#fcd134', label: sourceID, x: Math.random(), y: Math.random()});
                                    graph.edges.push({id:sourceID,source:sourceID,target:existingNode,label:cost,colour:'#282c34',size:0.5});
                                    g.addEdge(sourceID, destiantionID, cost);
                                    nodeIds.push(sourceID);


                                }
                                if (selectTier === "T3") {
                                    graph.nodes.push({id: sourceID, size: 3, color: '#ff1744', label: sourceID, x: Math.random(), y: Math.random()});
                                    graph.edges.push({id:sourceID,source:sourceID,target:existingNode,label:cost,colour:'#282c34',size:0.5});
                                    g.addEdge(sourceID, destiantionID, cost);
                                    nodeIds.push(sourceID);


                                }
                                if (selectTier === "IX") {
                                    graph.nodes.push({id: sourceID, size: 3, color: '#008cc2', label: sourceID, x: Math.random(), y: Math.random()});
                                    graph.edges.push({id:sourceID,source:sourceID,target:existingNode,label:cost,colour:'#282c34',size:0.5});
                                    g.addEdge(sourceID, destiantionID, cost);
                                    nodeIds.push(sourceID);


                                }
                                if (Etype === "P") {
                                    graph.edges.push({id: sourceID, source: sourceID, target: destiantionID, label: cost, color: '#282c34', size: 0.5});

                                    g.addEdge(sourceID, destiantionID, cost);
                                    nodeIds.push(sourceID);

                                }
                                if (Etype === "PC") {
                                    graph.edges.push({id: sourceID, source: sourceID, target: destiantionID, label: cost, color: '#ff0000', size: 0.5});

                                    g.addEdge(sourceID, destiantionID, cost);
                                    nodeIds.push(sourceID);

                                }
                                if (Etype === "CP") {
                                    graph.edges.push({id: sourceID, source: sourceID, target: destiantionID, label: cost, color: '#46ff33', size: 0.5});

                                    g.addEdge(sourceID, destiantionID, cost);
                                    nodeIds.push(sourceID);

                                }
                                if (Etype === "IX") {
                                    graph.edges.push({id: sourceID, source: sourceID, target: destiantionID, label: cost, color: '#33fcff', size: 0.5});

                                    g.addEdge(sourceID, destiantionID, cost);
                                    nodeIds.push(sourceID);

                                }




                                //console.log(graph.edges);
                                s.graph.clear();
                                s.graph.read(graph);
                                //  signma draws the graph
                                //s.startForceAtlas2();
                                s.refresh();





                            }
                            function submitFunction() {
                                
                                if (graph.nodes[0].id) {
                                    var x = document.getElementById("selectStart").value;
                                    var y = document.getElementById("selectEnd").value;
                                    var a = document.getElementById("selectRoutingAlgorithm").value;

                                    

                                    var isnumx = "";
                                    var isnumy = "";

                                    if (!isnumx) {
                                        if (!isnumy) {

                                            //console.log(g.vertexMap);
                                            if (a=="Dijikstra"){
                                                g.dijikstraAlgorithm(x);
                                                var endNode = g.getVertex(y);
                                                var distance = endNode.getDistance();
                                                document.getElementById(
                                                    "demo").innerHTML = "The cost is: " + distance;
                                            //graph.nodes[0].id; 
                                                var finalPath = g.printOutPath(endNode);
                                                var printPath = finalPath.slice(3, finalPath.length);
                                                document.getElementById(
                                                    "demo2").innerHTML = "The lowest cost path is: " + printPath;
                                                }
                                            if (a == "Bellman-Ford"){
                                                // console.log("still working on it");
                                            //     var endNode = g.getVertex(y);
                                            //     var distance = endNode.getDistance();
                                            //     document.getElementById(
                                            //         "demo").innerHTML = "The cost is: " + distance;
                                            // //graph.nodes[0].id; 
                                            //     var finalPath = g.printOutPath(endNode);
                                            //     var printPath = finalPath.slice(3, finalPath.length);
                                            //     document.getElementById(
                                            //         "demo2").innerHTML = "The lowest cost path is: " + printPath;
                                            document.getElementById("demo2").innerHTML = "Still working on Bellman Ford";
                                            }
                                            if (a == "Routing Algorithm"){
                                                document.getElementById("demo2").innerHTML = "No algorithm selected";
                                            }
                                         
                                            
                                            
                                            //console.log(x);
                                            
                                            
                                            // sigma.plugins.animate(
                                            //     s,
                                            //     {
                                            //     x: 'to_x',
                                            //     y: 'to_y',
                                            //     size: 'to_size',
                                            //     color: 'to_color'
                                            //     },
                                            //     {
                                            //     nodes: ['1', '2', '3']
                                            //     }
                                            // );



                                            csvContent += "From Node " + x + " to Node " + y + " the cost is: " + distance + "\r\n";
                                            csvContent += "From Node " + x + " to Node " + y + " the lowest cost path is: " + printPath + "\r\n";

                                        } else {
                                            document.getElementById(
                                                    "demo").innerHTML = "Start Node Valid";
                                            document.getElementById(
                                                    "demo2").innerHTML = "End Node Invalid!";

                                        }
                                    } else {

                                        document.getElementById(
                                                "demo").innerHTML = "Start Node Invalid!";
                                    }



                                } else {

                                    document.getElementById(
                                            "demo").innerHTML = "ERROR!!!";

                                    document.getElementById(
                                            "demo2").innerHTML = "Please select an input .csv file to build simulation. ";


                                }

                            }

                            function saveFunction() {

                                var encodedUri = encodeURI(csvContent);
                                var link = document.createElement("a");
                                link.setAttribute("href", encodedUri);
                                link.setAttribute("download", "my_data.csv");
                                document.body.appendChild(link); // Required for FF
                                link.click(); // This will download the data file named "my_data.csv"    
                            }

                            function saveTPFunction(){

                            //load data from database into  csvContent2 here if needed

                            var csvContent2 = "data:text/csv;charset=utf-8,";
                            var datafetch = Object.entries(localStorage);
                            
                            var splitexportdata = [];



                            for(var i = 0; i < datafetch.length; i++){
                                splitexportdata = splitexportdata.concat(datafetch[i]);
                            }

                            
                            
                            csvContent2 += "NodeID,NodeType,CountryCode" + "\r\n";
                            
                            for(i=0;i<splitexportdata.length;i++){

                                
                                    
                                if(splitexportdata[i].charAt(0)==="%" && splitexportdata[i].charAt(1)=== "n" ){
                                    if(splitexportdata[i]&&splitexportdata[i+1]){
                                        var splitagain = splitexportdata[i].substr(2);
                                    //  var test = spliagain[1].trim() + "," + splitexportdata[i+1].trim() ;
                                    //  
                                    //console.log(splitagain);

                                    //  console.log("##########");
                                    //  console.log("##########");
                                    //  console.log("##########");
                                        csvContent2+= splitagain.trim() + "," + splitexportdata[i+1].trim() + "\r\n";
                                    
                                    
                                    }
                                }
                            }



                            csvContent2 += "Source,Destination,Type,Cost,Delay" + "\r\n";

                            for(i=0;i<splitexportdata.length;i++){

                                
                                    if(splitexportdata[i].charAt(0)==="%" && splitexportdata[i].charAt(1)=== "e" ){
                                        if(splitexportdata[i]&&splitexportdata[i+1]){
                                            

                                        csvContent2+= splitexportdata[i+1].trim() + "\r\n"; 
                                    }
                                    
                                }
                            }
                            
                            


                            var encodedUri = encodeURI(csvContent2);
                            var link = document.createElement("a");
                            link.setAttribute("href", encodedUri);
                            link.setAttribute("download", "my_topology_data.csv");
                            document.body.appendChild(link); // Required for FF
                            link.click(); // This will download the data file named "my_topology_data.csv"
                        }

            </script>

        <script>
            var coll = document.getElementsByClassName("collapsible");
            var i;

            for (i = 0; i < coll.length; i++) {
                coll[i].addEventListener("click", function() {
                    this.classList.toggle("active");
                    var content = this.nextElementSibling;
                    if (content.style.display === "block") {
                        content.style.display = "none";
                    } 
                    else {
                        content.style.display = "block";
                    }
                });
            }
        </script>
        
        </div>

        <!--Main screen display-->
        <div class="main">
            <div id="container" style="height: 100%; width: 100%">
            </div>
            <script>
                // dijikstra's algorithm classes STARTS here
                class Edge {
                    constructor(d, c) {
                        this.dest = d;
                        this.cost = c;

                    }
                }

                class Vertex {

                    constructor(name) {
                        this.name = name;
                        this.subtract = false;
                        this.adj = [];
                        this.dist = 0;
                        this.scratch = 0;
                        this.paths = [];
                        this.prev = null;
                        this.reset();
                    }

                    reset() {
                        this.scratch = 0;

                        this.dist = Infinity;

                        this.prev = null;

                    }

                    hasEdge() {
                        if (this.adj.length == 0) {
                            return false;
                        } else {
                            return true;
                        }
                    }

                    getDistance() {
                        return this.dist;
                    }
                }

                class Path {
                    constructor(d, c) {
                        this.dest = d;
                        this.cost = c;
                    }

                    compareTo(otherPath) {
                        otherCost = otherPath.cost;
                        return otherCost < otherPath ? -1 : otherCost > otherPath ? 1 : 0;
                    }
                }


                function bellmanFord(graph, startVertex) {
                    const distances = {};
                    const previousVertices = {};

                    // Init all distances with infinity assuming that currently we can't reach
                    // any of the vertices except start one.
                    distances[startVertex.getKey()] = 0;
                    graph.getAllVertices().forEach((vertex) => {
                        previousVertices[vertex.getKey()] = null;
                        if (vertex.getKey() !== startVertex.getKey()) {
                        distances[vertex.getKey()] = Infinity;
                        }
                    });

                    // We need (|V| - 1) iterations.
                    for (let iteration = 0; iteration < (graph.getAllVertices().length - 1); iteration += 1) {
                        // During each iteration go through all vertices.
                        Object.keys(distances).forEach((vertexKey) => {
                        const vertex = graph.getVertexByKey(vertexKey);

                        // Go through all vertex edges.
                        graph.getNeighbors(vertex).forEach((neighbor) => {
                            const edge = graph.findEdge(vertex, neighbor);
                            // Find out if the distance to the neighbor is shorter in this iteration
                            // then in previous one.
                            const distanceToVertex = distances[vertex.getKey()];
                            const distanceToNeighbor = distanceToVertex + edge.weight;
                            if (distanceToNeighbor < distances[neighbor.getKey()]) {
                            distances[neighbor.getKey()] = distanceToNeighbor;
                            previousVertices[neighbor.getKey()] = vertex;
                            }
                        });
                        });
                    }

                    return {
                        distances,
                        previousVertices,
                    };
                    }



                class routingAlgorithms {
                    constructor() {
                        //this.Infinity = this.Infinity;
                        this.vertexMap = {};
                    }

                    clearAll() {
                        for (var v of Object.values(this.vertexMap)) {

                            v.reset();
                            //console.log("distance after reset : " + v.getDistance());

                        }
                    }

                    printOutPath(dest) {
                        console.log(path);
                        console.log(dest.name);
                        var path = "";
                        if (dest.paths.length != 0) {
                            path += this.printOutPath(dest.paths[0])

                        }
                        path += "-->" + dest.name;
                        return path;
                    }

                    unweightedBFS(startNode) {
                       
                        this.clearAll();
                        
                        if (!startNode in this.vertexMap) {
                            console.log("Start vertex not found");
                        }
                        var start = this.vertexMap[startNode];

                        var pq = [];

                        pq.push(start);
                        start.dist = 0;
                        while (!(pq.length == 0)) {
                            var vertex = pq.shift();
                            for (var edge in vertex.adj) {
                                console.log(edge);
                                var w = edge.dest;
                                console.log
                                if (w.dist == Infinity) {
                                    w.dist = vertex.dist + 1;
                                    w.prev = vertex;
                                    pq.push(w);

                                }
                                // w.paths.push(vertex);
                                // pq.push(new Path(w, w.dist));
                            }
                        }

                    }

                    acyclic(startNode) {
                        var pq = [];
                        

                        if (!(startNode in this.vertexMap)) {
                            console.log("Start vertex not found");
                            //window.close();
                        }
                        var start = this.vertexMap[startNode];
                        this.clearAll();



                        pq.push(new Path(start, 0));
                        start.dist = 0;
                        var nodesSeen = 0;
                        var vertexSet = {};
                        vertexSet = Object.values(this.vertexMap);
                        //console.log(vertexSet);

                        for (var vertex in vertexSet) {
                            for (var edge in vertex.adj) {
                                edge.dest.scratch++;
                            }
                        }
                        for (vertex in vertexSet) {
                            if (vertex.scratch == 0) {
                                pq.push(vertex);
                            }
                        }

                        var iterations;
                        for (iterations = 0; !pq.length == 0; iterations++) {
                            vertex = pq.shift();
                            for (var edge in vertex.adj) {
                                var w = edge.dest;
                                cvw = edge.cost;

                                if (--w.scratch == 0) {
                                    q.add(w);
                                }
                                if (vertex.dist == Infinity) {
                                    continue;
                                }
                                if (w.dist > v.dist + cvw) {
                                    w.dist = vertex.dist + cvw;
                                    w.prev = v;
                                    w.paths = [];
                                }
                                w.paths.push(v);
                                pq.push(new Path(w, w.dist));
                            }
                        }
                        if (iterations != Object.keys(this.vertexMap).length) {
                            console.log("Graph has a cycle");
                            //window.close();
                        }

                    }

                    

                    dijikstraAlgorithm(startNode) {
                        
                        var pq = []
                        if (!(startNode in this.vertexMap)) {
                            console.log("Start vertex not found");
                            //window.close();
                        }
                        var start = this.vertexMap[startNode];
                        //console.log(this.vertexMap);
                        this.clearAll();
                        //console.log(this.vertexMap);

                        pq.push(new Path(start, 0));
                        start.dist = 0;
                        var nodesSeen = 0;
                        start.paths = [];
                        while (pq.length != 0 && nodesSeen < Object.keys(this.vertexMap).length) {
                            var vrec = pq.shift();
                            var v = vrec.dest;
                            if (v.scratch != 0)
                                continue;

                            v.scratch = 1;
                            nodesSeen++;
                            //console.log("v name: " + v.adj[0].dest.name);

                            var e = 0;
                            for (e = 0; e < v.adj.length; e++) {
                                var w = v.adj[e].dest;
                                //console.log("Edges: " + v.adj[e].dest.name);
                                var cvw = v.adj[e].cost;

                                if (cvw < 0)
                                    console.log("Graph has negative edges");

                                if (w.dist >= v.dist + cvw) {
                                    if (w.dist > v.dist + cvw) {
                                        w.dist = v.dist + cvw;
                                        w.paths = [];
                                    }
                                    w.paths.push(v);
                                    pq.push(new Path(w, w.dist));
                                }
                            }



                        }


                    }

                    addEdge(sourceName, destName, cost) {

                        var v = this.getVertex(sourceName);
                        var w = this.getVertex(destName);
                        var newEdge = new Edge(w, cost);
                        //console.log("new edge: " + newEdge.dest.name);
                        v.adj.push(newEdge);

                    }

                    addEdgeSingle(sourceName,typeOfNode) {
                        var v = this.getVertex(sourceName);
                        //v.subtract = 
                        
    

                    }
                    getVertex(vertexName) {
                        if (vertexName in this.vertexMap) {
                            return this.vertexMap[vertexName];
                        }
                        var v = new Vertex(vertexName);
                        this.vertexMap[vertexName] = v;
                        return v;
                    }

                }

                var g = new routingAlgorithms();


                // dijikstra's algorithm classes ENDS here
                var s = new sigma(
                        {
                            renderer: {
                                container: document.getElementById('container'),
                                type: 'canvas'
                            },
                            settings: {
                                minEdgeSize: 0.1,
                                maxEdgeSize: 2,
                                midNodeSize: 1,
                                maxNodeSize: 20,
                            }
                        }
                );




                // Initialize the dragNodes plugin:
                var dragListener = sigma.plugins.dragNodes(s, s.renderers[0]);
                dragListener.bind('startdrag', function (event) {
                    console.log(event);
                });
                dragListener.bind('drag', function (event) {
                    console.log(event);
                });
                dragListener.bind('drop', function (event) {
                    console.log(event);
                });
                dragListener.bind('dragend', function (event) {
                    console.log(event);
                });
                var graph = {
                    nodes: [
                    ],
                    edges: [
                    ]
                }
               
                var openFile = function (event) {
                    //console.log("changed file");
                    window.localStorage.clear();
                    localStorage.clear();
                    
                    graph.nodes = [];
                    graph.edges = [];
                    var nodeTiers = ["T1","T2","T3","IXP"];
                    var algorithmChoice = ["Dijikstra","Bellman-Ford"];
                    
                    for (choice in algorithmChoice){
                        selectRoutingAlgorithm.add(new Option(algorithmChoice[choice]));
                    }

                    
                    //console.log(countries);
                    
                    s.graph.clear();
                    //console.log(nodeIds);

                    var input = event.target;
                    var reader = new FileReader();
                    reader.onload = function () {

                        var text = reader.result;
                        var lines = text.split("\n");
                        var counter = 1;
                        var line = lines[counter];
                        line = line.trim();
                        var radius = 10;
                        while (line != "Source,Destination,Type,Cost,Delay") {
                            //console.log(line);



                            splitLines = line.split(",");

                             //logical block to add Node data from csv to database

     //############################################################################################################


                         if (typeof(Storage) !== "undefined") {

                            nodecounter++;
                            


                            var m = "%n"+ splitLines[0].trim();
                          
                            var n = splitLines[1].trim() + "," + splitLines[2].trim();
                            localStorage.setItem(m,n);


                         }
                         else {
                                document.getElementById("result").innerHTML = "Sorry, your browser does not support Web Storage...";
                            }



//##########################################################################################################

                            if (splitLines[1] === "T1") {
                                var a = Math.random() * 2 * 3.142;

                                // adds to the graph here
                                graph.nodes.push({id: splitLines[0], size: 9, color: '#70c405', label: line, x: Math.cos(a) * radius, y: Math.sin(a) * radius});
                                g.addEdgeSingle(splitLines[0]);
                                nodeIds.push(splitLines[0]);

                                counter++;
                                line = lines[counter];
                                line = line.trim();

                            } else if (splitLines[1] === "T2") {
                                var a = Math.random() * 2 * 3.142;
                                // adds to the graph here
                                graph.nodes.push({id: splitLines[0], size: 6, color: '#fcd134', label: line, x: Math.cos(a) * radius, y: Math.sin(a) * radius});
                                g.addEdgeSingle(splitLines[0]);

                                nodeIds.push(splitLines[0]);
                                counter++;
                                line = lines[counter];
                                line = line.trim();

                            } else if (splitLines[1] === "T3") {
                                var a = Math.random() * 2 * 3.142;
                                // adds to the graph here
                                graph.nodes.push({id: splitLines[0], size: 3, color: '#ff1744', label: line, x: Math.cos(a) * radius, y: Math.sin(a) * radius});
                                g.addEdgeSingle(splitLines[0]);

                                nodeIds.push(splitLines[0]);
                                counter++;
                                line = lines[counter];
                                line = line.trim();

                            } else if (splitLines[1] === "IX") {
                                var a = Math.random() * 2 * 3.142;
                                // adds to the graph here
                                graph.nodes.push({id: splitLines[0], size: 3, color: '#008cc2', label: line, x: Math.cos(a) * radius, y: Math.sin(a) * radius});
                                g.addEdgeSingle(splitLines[0]);
                                nodeIds.push(splitLines[0]);
                                counter++;
                                line = lines[counter];
                                line = line.trim();

                            }

                        }
                        //console.log(graph.nodes);
                        counter++;
                        line = lines[counter];
                        line = line.trim();
                        while (counter < lines.length) {
                            counter++;
                            //console.log(line);
                            splitLines = line.split(",");
// logical block to add edge data from .csv to datbase
//##################################################################################################################

                            if (typeof(Storage) !== "undefined") {

                                edgecounter++;
                                var k = "%edge" + edgecounter;

                                if(splitLines[0]){
                                var d = splitLines[0].trim() + "," + splitLines[1].trim() + "," + splitLines[2].trim() + "," + splitLines[3].trim() + "," + splitLines[4].trim() ; 
                                localStorage.setItem(k,d);
                                }

                            }
                            else {
                                document.getElementById("result").innerHTML = "Sorry, your browser does not support Web Storage...";
                            }

//###################################################################################################################


                            if (splitLines[2] === "P") {
                                graph.edges.push({id: "Edge" + counter, source: splitLines[0].trim(), target: splitLines[1].trim(), label: splitLines[3].trim(), color: '#282c34', size: 0.5})
                                var cost = parseInt(splitLines[3]);
                                g.addEdge(splitLines[0].trim(), splitLines[1].trim(),cost);
                                line = lines[counter];

                            } else if (splitLines[2] === "PC") {
                                graph.edges.push({id: "Edge" + counter, source: splitLines[0].trim(), target: splitLines[1].trim(), label: splitLines[3].trim(), color: '#ff0000', size: 0.5})
                                var cost = parseInt(splitLines[3]);
                                g.addEdge(splitLines[0].trim(), splitLines[1].trim(),cost);
                                line = lines[counter];

                            } else if (splitLines[2] === "CP") {

                                graph.edges.push({id: "Edge" + counter, source: splitLines[0].trim(), target: splitLines[1].trim(), label: splitLines[3].trim(), color: '#46ff33', size: 0.5})
                                var cost = parseInt(splitLines[3]);
                                g.addEdge(splitLines[0].trim(), splitLines[1].trim(),cost);
                                line = lines[counter];
                            } else if (splitLines[2] == "IX") {
                                graph.edges.push({id: "Edge" + counter, source: splitLines[0].trim(), target: splitLines[1].trim(), label: splitLines[3].trim(), color: '#33fcff', size: 0.5})
                                var cost = parseInt(splitLines[3]);
                                g.addEdge(splitLines[0].trim(), splitLines[1].trim(),cost);
                                line = lines[counter];

                            }
                         
                         



                        }

                        for(var i = 0; i < nodeIds.length; i++) {
                                selectStart.add( new Option( nodeIds[i]));
                                selectEnd.add(new Option(nodeIds[i]));
                                existingNode.add(new Option(nodeIds[i]));
                                nodeToDelete.add(new Option(nodeIds[i]));
                        }
                      
                        for (tier in nodeTiers){
                            selectTier.add(new Option(nodeTiers[tier]));
                        }


                        //console.log(graph.edges);
                        //load the graph into sigma
                        s.graph.read(graph);
                        // signma draws the graph
                        s.refresh();
                        //s.startForceAtlas2();
                        
                        



                    };
                    reader.readAsText(input.files[0]);
                    var force = false;
                    document.getElementById('layout').onclick = function() {
                    if (!force)
                        s.startForceAtlas2({slowDown: 10});
                    else
                        s.stopForceAtlas2();
                    force = !force;
                    };

                    // document.getElementById('export').onclick = function() {
                    // console.log('exporting...');
                    // //console.log(s.renderers[0].snapshot({format: 'png', background: 'white', filename: 'my-graph.png', labels: false}));
                    // console.log((s.renderers[0], download = true, file = "graph.png",background = "white", format = "png", labels = false))
                    // //console.log(s.renderers[0].snapshot({format: 'png', background: 'white', filename: 'my-graph.png', labels: false}));
                    // // console.log(output);
                    // s.addRenderer({id: 'myName', container: 'container'});

                    // s.renderers.myName.snapshot();
                    // }
                  

                };
            </script>
        </div>

    </body>
    
</html>
